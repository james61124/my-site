<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Algorithm - category - James Blog</title>
        <link>https://jamesblogger.com/categories/Algorithm/</link>
        <description>Algorithm - category - James Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sun, 23 Feb 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="https://jamesblogger.com/categories/Algorithm/" rel="self" type="application/rss+xml" /><item>
    <title>[ Leetcode 167 ] Two Sum II - Input Array Is Sorted | Solution Approach &amp; Explanation</title>
    <link>https://jamesblogger.com/program/leetcode-167/</link>
    <pubDate>Sun, 23 Feb 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/leetcode-167/</guid>
    <description><![CDATA[This problem is a variation of Two Sum. Given an array sorted in ascending order, the goal is to find two numbers whose sum equals the target value and return their 1-based indices.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/two-sum-ii-input-array-is-sorted/
Method - Two Pointersï¼ˆOpposite Directionï¼‰ This problem can be solved using opposite direction two-pointer technique, since this problem is about finding elements under certain constraints in a sorted array. Set left pointer at the first element and right pointer at the last element.]]></description>
</item><item>
    <title>[ Leetcode 125 ] Valid Palindrome | Solution Approach &amp; Explanation</title>
    <link>https://jamesblogger.com/program/leetcode-125/</link>
    <pubDate>Sat, 15 Feb 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/leetcode-125/</guid>
    <description><![CDATA[This problem requires determining whether a given string is a palindrome, ignoring case and non-alphanumeric characters.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/valid-palindrome/
Solution - Opposite Direction Two Pointers This problem can be solved using an opposite direction two-pointer approach. The idea is to check whether the characters at the left and right pointers are the same. If they are, both pointers move inward. The main points to consider are ensuring that left and right do not go out of bounds and using isalnum() to check whether a character is alphanumeric.]]></description>
</item><item>
    <title>[ Leetcode 209 ] Minimum Size Subarray Sum | Solution Approach &amp; Explanation</title>
    <link>https://jamesblogger.com/program/leetcode-209/</link>
    <pubDate>Wed, 29 Jan 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/leetcode-209/</guid>
    <description><![CDATA[Given a positive integer array nums and a target value target, find the smallest contiguous subarray whose sum is greater than or equal to target. If no such subarray exists, return 0.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/minimum-size-subarray-sum/
Method 1 - Sliding Window This problem can be solved using the Sliding Window technique. Since all numbers in the array are positive, we know that if a subarray sum reaches or exceeds target, adding more numbers will only make it longer but won&rsquo;t help find the shortest subarray.]]></description>
</item><item>
    <title>[ Leetcode 300 ] Longest Increasing Subsequence | Solution Approach &amp; Explanation</title>
    <link>https://jamesblogger.com/program/leetcode-300/</link>
    <pubDate>Wed, 29 Jan 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/leetcode-300/</guid>
    <description><![CDATA[Given an array, find the longest increasing subsequence (LIS). The elements in this subsequence must appear in increasing order but do not need to be consecutive in the original array.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/longest-increasing-subsequence/
Method 1 - Dynamic Programming Time Complexity - O( n^2 ), due to the nested loops.
Space Complexity - O( n ), as we need an array of size n for dp.
Step 1 Create a dp array where dp[i] represents the length of the LIS that ends at nums[i].]]></description>
</item><item>
    <title>[ Leetcode 841 ] Keys and Rooms | Solution Approach &amp; Explanation</title>
    <link>https://jamesblogger.com/program/leetcode-841/</link>
    <pubDate>Wed, 29 Jan 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/leetcode-841/</guid>
    <description><![CDATA[There are n rooms labeled from 0 to n-1. Each rooms[i] contains a list of keys that can be used to unlock other rooms. Initially, you start in room 0, which is already unlocked. The goal is to determine whether you can visit all rooms.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/keys-and-rooms/
Solution - DFS This problem can be solved using Depth-First Search (DFS), as it is essentially a graph traversal problem. The rooms and their keys form a directed graph, where a key in rooms[i] represents an edge from room i to another room.]]></description>
</item><item>
    <title>Binary Search</title>
    <link>https://jamesblogger.com/program/binary-search/</link>
    <pubDate>Tue, 28 Jan 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/binary-search/</guid>
    <description><![CDATA[Binary Search is a searching algorithm used to find the position of a key value in a sorted array. It works by repeatedly narrowing the search range in half, allowing it to quickly locate the target. As a result, the time complexity of Binary Search is O(logn).
Basic Steps Compare the target with the middle value. If they are equal, return the index. If the target is less than the middle value, narrow the search range to the left half.]]></description>
</item><item>
    <title>DP Series - The Rod Cutting Problem</title>
    <link>https://jamesblogger.com/program/the-rod-cutting-problem/</link>
    <pubDate>Sun, 21 Jan 2024 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>https://jamesblogger.com/program/the-rod-cutting-problem/</guid>
    <description><![CDATA[Given that selling a rod of length i yields a profit of pi , how do we cut a rod of length n to maximize the total revenue?
Method 1: Recursion The most straightforward approach is to solve it using recursion. As shown in the figure below, rn represents the maximum revenue obtainable by cutting a rod of length n. Suppose i is the length of the first segment in the optimal solution; then rn = pi + rnâˆ’i, because pi is the revenue from the first segment in the optimal solution, and adding the maximum revenue from the remaining part gives us the answer.]]></description>
</item></channel>
</rss>
