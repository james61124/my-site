<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>String - tag - James Blog</title>
        <link>http://localhost:32997/tags/String/</link>
        <description>String - tag - James Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 06 Mar 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://localhost:32997/tags/String/" rel="self" type="application/rss+xml" /><item>
    <title>[ Leetcode 20 ] Valid Parentheses | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-20/</link>
    <pubDate>Thu, 06 Mar 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-20/</guid>
    <description><![CDATA[Given a string s containing only the characters (, ), {, }, [ and ], check whether the string forms a valid set of parentheses.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/valid-parentheses/
Problem Analysis This is a classic First In, Last Out (FILO) problem, which makes a stack the ideal data structure for solving it. We also need to consider edge cases carefully.
Solution - Stack We use a stack while iterating through the string:
If we encounter a left parenthesis, we push it onto the stack.]]></description>
</item><item>
    <title>[ Leetcode 227 ] Basic Calculator II | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-227/</link>
    <pubDate>Thu, 06 Mar 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-227/</guid>
    <description><![CDATA[Given a string containing non-negative integers, +, -, *, /, and spaces, evaluate its value while following the standard order of operations (multiplication and division before addition and subtraction). The use of eval() is not allowed.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/basic-calculator-ii/
Problem Analysis Since multiplication and division must be processed before addition and subtraction, the problem requires handling Last In, First Out (LIFO) operations. This suggests that a stack would be an effective data structure to use.]]></description>
</item><item>
    <title>[ Leetcode 496 ] Next Greater Element I | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-496/</link>
    <pubDate>Thu, 06 Mar 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-496/</guid>
    <description><![CDATA[Given two arrays nums1 and nums2, where nums1 is a subset of nums2, we need to find the next greater element for each number in nums1 within nums2.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/next-greater-element-i/
Problem Analysis The key challenge is how to efficiently find the next greater element for each number in nums1 without iterating over nums2 repeatedly. A brute-force approach would be too slow, so we need an optimized method.
Solution - Monotone Stack The design of the Monotone Stack fits perfectly for this problem because we can ensure that the numbers in the stack are always in decreasing order.]]></description>
</item><item>
    <title>[ Leetcode 739 ] Daily Temperatures | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-739/</link>
    <pubDate>Thu, 06 Mar 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-739/</guid>
    <description><![CDATA[Given an integer array temperatures, representing the temperature on each day, for each day, we need to find the nearest future day with a higher temperature and return the number of days between the current day and that day. If there is no higher temperature in the future, return 0.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/daily-temperatures/
Problem Analysis The key to this problem is finding the next number greater than the current one, so we can directly think of using a Monotone Stack.]]></description>
</item><item>
    <title>[ Leetcode 1143 ] Longest Common Subsequence | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-1143/</link>
    <pubDate>Sat, 01 Mar 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-1143/</guid>
    <description><![CDATA[Given two strings, text1 and text2, find the length of their Longest Common Subsequence (LCS).
âš ï¸ Note:
A subsequence does not need to be contiguous but must maintain the original order. If there is no common subsequence, return 0. LinkðŸ”—ï¼šhttps://leetcode.com/problems/longest-common-subsequence/
Solution - DP (Double-Sequence Linear DP Problem) This problem can be solved using Double-Sequence Linear DP, as the input consists of two strings. We define dp[i+1][j+1] to represent the length of the longest common subsequence (LCS) ending at text1[i] and text2[j].]]></description>
</item></channel>
</rss>
