<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Dynamic Programming - tag - James Blog</title>
        <link>http://localhost:32997/tags/Dynamic-Programming/</link>
        <description>Dynamic Programming - tag - James Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Sat, 01 Mar 2025 00:00:00 &#43;0000</lastBuildDate><atom:link href="http://localhost:32997/tags/Dynamic-Programming/" rel="self" type="application/rss+xml" /><item>
    <title>[ Leetcode 1143 ] Longest Common Subsequence | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-1143/</link>
    <pubDate>Sat, 01 Mar 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-1143/</guid>
    <description><![CDATA[Given two strings, text1 and text2, find the length of their Longest Common Subsequence (LCS).
âš ï¸ Note:
A subsequence does not need to be contiguous but must maintain the original order. If there is no common subsequence, return 0. LinkðŸ”—ï¼šhttps://leetcode.com/problems/longest-common-subsequence/
Solution - DP (Double-Sequence Linear DP Problem) This problem can be solved using Double-Sequence Linear DP, as the input consists of two strings. We define dp[i+1][j+1] to represent the length of the longest common subsequence (LCS) ending at text1[i] and text2[j].]]></description>
</item><item>
    <title>[ Leetcode 300 ] Longest Increasing Subsequence | Solution Approach &amp; Explanation</title>
    <link>http://localhost:32997/program/leetcode-300/</link>
    <pubDate>Wed, 29 Jan 2025 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/leetcode-300/</guid>
    <description><![CDATA[Given an array, find the longest increasing subsequence (LIS). The elements in this subsequence must appear in increasing order but do not need to be consecutive in the original array.
LinkðŸ”—ï¼šhttps://leetcode.com/problems/longest-increasing-subsequence/
Method 1 - Dynamic Programming Time Complexity - O( n^2 ), due to the nested loops.
Space Complexity - O( n ), as we need an array of size n for dp.
Step 1 Create a dp array where dp[i] represents the length of the LIS that ends at nums[i].]]></description>
</item><item>
    <title>DP Series - The Rod Cutting Problem</title>
    <link>http://localhost:32997/program/the-rod-cutting-problem/</link>
    <pubDate>Sun, 21 Jan 2024 00:00:00 &#43;0000</pubDate><author>
        <name>James</name>
    </author><guid>http://localhost:32997/program/the-rod-cutting-problem/</guid>
    <description><![CDATA[Given that selling a rod of length i yields a profit of pi , how do we cut a rod of length n to maximize the total revenue?
Method 1: Recursion The most straightforward approach is to solve it using recursion. As shown in the figure below, rn represents the maximum revenue obtainable by cutting a rod of length n. Suppose i is the length of the first segment in the optimal solution; then rn = pi + rnâˆ’i, because pi is the revenue from the first segment in the optimal solution, and adding the maximum revenue from the remaining part gives us the answer.]]></description>
</item></channel>
</rss>
